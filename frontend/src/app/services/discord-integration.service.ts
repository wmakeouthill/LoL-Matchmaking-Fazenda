import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';
import { ApiService } from './api';

@Injectable({
  providedIn: 'root'
})
export class DiscordIntegrationService {
  private isBackendConnected = false;
  private discordUsersOnline: any[] = [];
  private currentDiscordUser: any = null;
  private isInDiscordChannel = false;

  // Observables para componentes
  private usersSubject = new BehaviorSubject<any[]>([]);
  private connectionSubject = new BehaviorSubject<boolean>(false);

  // Contador de inst√¢ncias para debug
  private static instanceCount = 0;
  private instanceId: number;

  // Throttling simplificado - apenas prote√ß√£o b√°sica contra spam
  private lastStatusRequest = 0;
  private readonly STATUS_REQUEST_COOLDOWN = 2000;

  // Sistema de atualiza√ß√µes autom√°ticas via WebSocket
  private autoUpdateInterval?: number;
  private readonly AUTO_UPDATE_INTERVAL = 60000;
  private lastAutoUpdate = 0;

  // ‚úÖ NOVO: Refer√™ncia para o ApiService para repassar mensagens
  private apiService: ApiService;
  private baseUrl: string;

  constructor(apiService: ApiService) {
    this.apiService = apiService;
    this.baseUrl = this.apiService.getBaseUrl();
    DiscordIntegrationService.instanceCount++;
    this.instanceId = DiscordIntegrationService.instanceCount;
    console.log(`üîß [DiscordService] Inst√¢ncia #${this.instanceId} criada (Total: ${DiscordIntegrationService.instanceCount})`);

    // ‚úÖ CORRE√á√ÉO: Usar WebSocket do ApiService em vez de criar conex√µes conflitantes
    console.log(`üîß [DiscordService #${this.instanceId}] Usando WebSocket do ApiService`);

    // Escutar mensagens WebSocket do ApiService
    this.apiService.onWebSocketMessage().subscribe({
      next: (message) => {
        const t = (message && typeof message.type === 'string') ? message.type : '';
        if (t && (t.startsWith('discord_') || t.includes('user'))) {
          this.handleBotMessage(message);
        }
      },
      error: (error) => {
        console.error(`‚ùå [DiscordService #${this.instanceId}] Erro no WebSocket:`, error);
        this.isBackendConnected = false;
        this.connectionSubject.next(false);
      }
    });

    // Verificar se ApiService WebSocket est√° conectado
    setTimeout(() => {
      if (this.apiService.isWebSocketConnected()) {
        this.isBackendConnected = true;
        this.connectionSubject.next(true);
        this.requestDiscordStatus();
      }
    }, 1000);
  }

  private handleBotMessage(data: any) {
    console.log(`üîç [DiscordService #${this.instanceId}] Processando mensagem:`, data.type, data);

    switch (data.type) {
      case 'discord_users_online':
        console.log(`üë• [DiscordService #${this.instanceId}] Usu√°rios Discord online recebidos:`, data.users?.length || 0, 'usu√°rios');
        this.discordUsersOnline = data.users || [];
        this.usersSubject.next(this.discordUsersOnline);
        this.lastAutoUpdate = Date.now();

        if (data.critical) {
          console.log(`üö® [DiscordService #${this.instanceId}] Broadcast CR√çTICO recebido - atualiza√ß√£o imediata`);
        }

        if (data.currentUser) {
          console.log(`üë§ [DiscordService #${this.instanceId}] Usu√°rio atual recebido via WebSocket:`, data.currentUser);
          this.currentDiscordUser = data.currentUser;
        }
        break;

      case 'discord_current_user':
        console.log(`üë§ [DiscordService #${this.instanceId}] Usu√°rio atual recebido:`, data.currentUser);
        this.currentDiscordUser = data.currentUser;
        break;

      case 'lcu_data_updated':
        console.log(`‚úÖ [DiscordService #${this.instanceId}] Dados do LCU atualizados com sucesso`);
        break;

      case 'discord_links_update':
        console.log(`üîó [DiscordService #${this.instanceId}] Vincula√ß√µes Discord atualizadas:`, data.links?.length || 0, 'links');
        break;

      case 'discord_status':
        console.log(`üéÆ [DiscordService #${this.instanceId}] Status do Discord recebido:`, data);
        this.isInDiscordChannel = data.inChannel || false;
        this.currentDiscordUser = null;

        if (data.isConnected !== undefined && data.isConnected !== null) {
          console.log(`üéÆ [DiscordService #${this.instanceId}] Atualizando status de conex√£o para:`, data.isConnected);
          this.isBackendConnected = data.isConnected;
          this.connectionSubject.next(data.isConnected);
        }
        break;

      case 'discord_channel_status':
        console.log(`üîç [DiscordService #${this.instanceId}] Status do canal Discord recebido:`, data);
        this.isInDiscordChannel = data.inChannel || false;
        console.log(`üîç [DiscordService #${this.instanceId}] Usu√°rios no canal: ${data.usersCount}, inChannel: ${data.inChannel}`);
        break;

      default:
        console.log(`‚ö†Ô∏è [DiscordService #${this.instanceId}] Tipo de mensagem n√£o reconhecido:`, data.type, data);
    }
  }

  // Solicitar status atual do Discord (com throttling e valida√ß√£o)
  requestDiscordStatus() {
    if (!this.apiService.isWebSocketConnected()) {
      console.warn(`‚ö†Ô∏è [DiscordService #${this.instanceId}] WebSocket n√£o est√° conectado, n√£o √© poss√≠vel solicitar status`);
      return;
    }

    const now = Date.now();
    if (now - this.lastStatusRequest < this.STATUS_REQUEST_COOLDOWN) {
      console.log(`‚è±Ô∏è [DiscordService #${this.instanceId}] Solicita√ß√£o ignorada (throttling): ${now - this.lastStatusRequest}ms desde √∫ltima solicita√ß√£o`);
      return;
    }

    this.lastStatusRequest = now;
    console.log(`üîç [DiscordService #${this.instanceId}] Solicitando status do Discord...`);

    try {
      const messages = [
        { type: 'get_discord_status' },
        { type: 'get_discord_users_online' }
      ];

      messages.forEach(msg => {
        if (this.apiService.isWebSocketConnected()) {
          console.log(`üì§ [DiscordService #${this.instanceId}] Enviando:`, msg.type);
          this.apiService.sendWebSocketMessage(msg);
        } else {
          console.warn(`‚ö†Ô∏è [DiscordService #${this.instanceId}] WebSocket desconectou durante envio de ${msg.type}`);
        }
      });
    } catch (error) {
      console.error(`‚ùå [DiscordService #${this.instanceId}] Erro ao enviar solicita√ß√µes de status:`, error);
    }
  }

  // Sistema de atualiza√ß√£o autom√°tica como backup
  private startAutoUpdate() {
    this.stopAutoUpdate();

    this.autoUpdateInterval = window.setInterval(() => {
      if (this.apiService.isWebSocketConnected()) {
        const now = Date.now();
        const timeSinceLastUpdate = now - this.lastAutoUpdate;

        if (timeSinceLastUpdate > 120000) {
          console.log(`üîÑ [DiscordService #${this.instanceId}] Atualiza√ß√£o autom√°tica (backup) - √∫ltima atualiza√ß√£o h√° ${Math.floor(timeSinceLastUpdate / 1000)}s`);
          this.requestDiscordStatus();
        }
      } else {
        console.log(`‚ö†Ô∏è [DiscordService #${this.instanceId}] WebSocket n√£o conectado durante auto-update, ignorando`);
      }
    }, this.AUTO_UPDATE_INTERVAL);
  }

  private stopAutoUpdate() {
    if (this.autoUpdateInterval) {
      clearInterval(this.autoUpdateInterval);
      this.autoUpdateInterval = undefined;
    }
  }

  // Entrar na fila Discord
  joinDiscordQueue(primaryLane: string, secondaryLane: string, username: string, lcuData?: { gameName: string, tagLine: string }) {
    console.log('üéÆ [DiscordService] === ENTRADA NA FILA DISCORD ===');

    if (!this.apiService.isWebSocketConnected()) {
      console.error('‚ùå [DiscordService] WebSocket n√£o conectado');
      return false;
    }

    if (!lcuData || !lcuData.gameName || !lcuData.tagLine) {
      console.error('‚ùå [DiscordService] Dados do LCU n√£o dispon√≠veis');
      return false;
    }

    const lcuFullName = `${lcuData.gameName}#${lcuData.tagLine}`;
    console.log('üîç [DiscordService] Procurando usu√°rio Discord para:', lcuFullName);

    const matchingUser = this.discordUsersOnline.find(user => {
      if (user.linkedNickname && user.linkedNickname.gameName && user.linkedNickname.tagLine) {
        const discordFullName = `${user.linkedNickname.gameName}#${user.linkedNickname.tagLine}`;
        return discordFullName === lcuFullName;
      }
      return false;
    });

    if (!matchingUser) {
      console.error('‚ùå [DiscordService] Usu√°rio Discord n√£o encontrado para:', lcuFullName);
      return false;
    }

    const message = {
      type: 'join_discord_queue',
      data: {
        discordId: matchingUser.id,
        gameName: lcuData.gameName,
        tagLine: lcuData.tagLine,
        lcuData: lcuData,
        linkedNickname: matchingUser.linkedNickname,
        preferences: {
          primaryLane: primaryLane,
          secondaryLane: secondaryLane
        }
      }
    };

    console.log('üéØ [DiscordService] Enviando entrada na fila Discord:', message);
    this.apiService.sendWebSocketMessage(message);
    return true;
  }

  leaveDiscordQueue() {
    if (!this.apiService.isWebSocketConnected()) {
      console.warn('‚ö†Ô∏è WebSocket n√£o est√° conectado');
      return;
    }

    const message = { type: 'leave_queue' };
    this.apiService.sendWebSocketMessage(message);
    console.log('üëã Saindo da fila Discord');
  }

  // Estados e verifica√ß√µes
  isConnected(): boolean {
    return this.apiService.isWebSocketConnected() && this.isBackendConnected;
  }

  isDiscordBackendConnected(): boolean {
    return this.apiService.isWebSocketConnected() && this.isBackendConnected;
  }

  isInChannel(): boolean {
    return this.isInDiscordChannel;
  }

  getCurrentDiscordUser(): any {
    return this.currentDiscordUser;
  }

  getDiscordUsersOnline(): any[] {
    return this.discordUsersOnline;
  }

  // Observables
  onUsersUpdate(): Observable<any[]> {
    return this.usersSubject.asObservable();
  }

  onConnectionChange(): Observable<boolean> {
    return this.connectionSubject.asObservable();
  }

  checkConnection(): void {
    console.log(`üîç [DiscordService #${this.instanceId}] Verificando conex√£o...`);
    if (this.apiService.isWebSocketConnected()) {
      this.requestDiscordStatus();
    } else {
      console.log(`‚ö†Ô∏è [DiscordService #${this.instanceId}] WebSocket n√£o conectado`);
    }
  }

  // M√©todo para enviar dados do LCU para identifica√ß√£o no backend
  sendLCUData(lcuData: { gameName: string, tagLine: string } | { displayName: string }): boolean {
    if (!this.apiService.isWebSocketConnected()) {
      console.error('‚ùå WebSocket n√£o conectado para enviar dados do LCU');
      return false;
    }

    console.log('üéÆ [DiscordService] Enviando dados do LCU para identifica√ß√£o:', lcuData);

    const message = {
      type: 'update_lcu_data',
      lcuData: lcuData
    };

    this.apiService.sendWebSocketMessage(message);
    return true;
  }

  // Cleanup
  ngOnDestroy() {
    console.log(`üõë [DiscordService #${this.instanceId}] Destruindo inst√¢ncia...`);
    this.stopAutoUpdate();
    this.usersSubject.complete();
    this.connectionSubject.complete();
    this.isBackendConnected = false;
    this.discordUsersOnline = [];
    this.currentDiscordUser = null;
    this.isInDiscordChannel = false;
    console.log(`‚úÖ [DiscordService #${this.instanceId}] Inst√¢ncia destru√≠da com sucesso`);
  }
}
