# üö® CORRE√á√ïES FINAIS DO DRAFT - ORDEM + TIMER + A√á√ïES

## ‚ùå **PROBLEMA #1: ORDEM DO DRAFT ERRADA**

### **Situa√ß√£o Atual (ERRADO):**

```
Fase 1 Bans:
- 0: Bot6 (Support team1) ‚ùå deveria ser TOP
- 1: Bot3 (Top team2) ‚úÖ
- 2: Bot5 (Bot team1) ‚ùå deveria ser JUNGLE  
- 3: Bot1 (Support team2) ‚ùå deveria ser JUNGLE
- 4: Bot4 (Top team1) ‚ùå deveria ser MID
- 5: Bot9 (Bot team2) ‚ùå deveria ser MID
```

### **Ordem CORRETA esperada:**

```
Fase 1 - Bans (6 a√ß√µes):
0: Top Azul (team1[0])
1: Top Vermelho (team2[0])
2: Jungle Azul (team1[1])
3: Jungle Vermelho (team2[1])
4: Mid Azul (team1[2])
5: Mid Vermelho (team2[2])

Fase 2 - Picks (6 a√ß√µes):
6: Top Azul (team1[0]) - First Pick
7: Top Vermelho (team2[0])
8: Jungle Vermelho (team2[1])
9: Jungle Azul (team1[1])
10: Mid Azul (team1[2])
11: Mid Vermelho (team2[2])

Fase 3 - Bans (4 a√ß√µes):
12: ADC Azul (team1[3])
13: ADC Vermelho (team2[3])
14: Support Azul (team1[4])
15: Support Vermelho (team2[4])

Fase 4 - Picks (4 a√ß√µes):
16: ADC Vermelho (team2[3])
17: Support Vermelho (team2[4])
18: ADC Azul (team1[3])
19: Support Azul (team1[4]) - Last Pick
```

### **üîß CORRE√á√ÉO: getPlayerForTeamAndIndex()**

**Arquivo:** `DraftFlowService.java` linha ~845-905

**O problema:** O mapeamento atual est√° usando √≠ndices errados!

Analisando o JSON:

- `team1[0]` = Bot4 (assignedLane: top) ‚úÖ
- `team1[1]` = FZD Ratoso (assignedLane: jungle) ‚úÖ
- `team1[2]` = Bot2 (assignedLane: mid) ‚úÖ
- `team1[3]` = Bot5 (assignedLane: bot) ‚úÖ
- `team1[4]` = Bot6 (assignedLane: support) ‚úÖ

Mas as a√ß√µes mostram:

- A√ß√£o 0 (deveria ser team1[0] Top): est√° pegando Bot6 (team1[4] Support)

**Causa:** O switch case est√° usando os √≠ndices da ORDEM CORRIGIDA que voc√™ explicou, mas o c√≥digo atual AINDA est√° mapeando errado.

---

## ‚ùå **PROBLEMA #2: TIMER N√ÉO ATUALIZA**

### **Diagn√≥stico:**

**Backend envia:** ‚úÖ

```java
updateData.put("timeRemaining", (int) Math.ceil(remainingMs / 1000.0));
// Linha 586 de DraftFlowService.java
```

**Frontend recebe:** ‚úÖ

```typescript
// app.ts linha 493
document.dispatchEvent(new CustomEvent('draftTimerUpdate', {
  detail: {
    matchId: this.draftData.matchId,
    timeRemaining: newTimeRemaining
  }
}));
```

**Componente escuta:** ‚úÖ

```typescript
// draft-pick-ban.ts linha 359
document.addEventListener('draftTimerUpdate', (event: any) => {
  // ...
  this.updateTimerFromBackend(event.detail);
});
```

**Mas:** `updateTimerFromBackend()` atualiza, mas **OnPush n√£o detecta mudan√ßa!**

### **üîß CORRE√á√ÉO: For√ßar detec√ß√£o no HTML**

**Problema:** O timer est√° no template HTML, mas OnPush n√£o re-renderiza.

**Solu√ß√£o:** Adicionar `| async` ou usar `ngZone.run()`.

---

## ‚ùå **PROBLEMA #3: A√á√ÉO N√ÉO SALVA**

### **Sintomas:**

- Usu√°rio clica no campe√£o no modal
- Modal fecha
- Mas o campe√£o N√ÉO aparece no slot
- Draft N√ÉO avan√ßa para pr√≥xima a√ß√£o
- currentIndex continua em 15

### **Diagn√≥stico:**

**Frontend envia:** (linha ~1997 draft-pick-ban.ts)

```typescript
const requestData = {
  matchId: effectiveMatchId,
  playerId: playerIdentifier,
  championId: champion.id,  // Nome: "Ahri"
  action: currentPhase.action,
  actionIndex: this.session.currentAction
};

// POST /match/draft-action
```

**Backend recebe e valida:** (linha ~256 DraftFlowService.java)

```java
@Transactional
public synchronized boolean processAction(long matchId, int actionIndex, String championId, String byPlayer) {
    // Normaliza championId
    // Valida time
    // Valida duplicata
    // Cria DraftAction
    // Salva no banco
    // Faz broadcast
}
```

**Mas:** Se retornar `false`, a a√ß√£o N√ÉO √© salva e N√ÉO h√° broadcast!

### **Poss√≠veis causas:**

1. **Valida√ß√£o de time falha:**

   ```java
   if (!st.isPlayerInTeam(byPlayer, prev.team())) {
       return false; // ‚ùå Jogador n√£o pertence ao time
   }
   ```

2. **actionIndex diferente de currentIndex:**

   ```java
   if (actionIndex != st.currentIndex) {
       return false; // ‚ùå Tentando fazer a√ß√£o fora de ordem
   }
   ```

3. **Campe√£o j√° foi usado:**

   ```java
   boolean alreadyUsed = st.actions.stream()
       .filter(a -> a.championId() != null && !SKIPPED.equalsIgnoreCase(a.championId()))
       .anyMatch(a -> normalizedChampionId.equalsIgnoreCase(a.championId()));
   if (alreadyUsed) {
       return false; // ‚ùå Campe√£o duplicado
   }
   ```

---

## ‚úÖ **SOLU√á√ÉO COMPLETA**

### **PASSO 1: Corrigir ordem do draft**

Voc√™ precisa verificar se o `getPlayerForTeamAndIndex()` est√° realmente usando os √≠ndices corretos.

**Verifique se est√° assim:**

```java
// FASE 1 - BANS (a√ß√µes 0-5): Top ‚Üí Jungle ‚Üí Mid de ambos os times
case 0:
    playerIndex = 0;
    break; // team1[0] - Top Azul
case 1:
    playerIndex = 0;
    break; // team2[0] - Top Vermelho
case 2:
    playerIndex = 1;
    break; // team1[1] - Jungle Azul
case 3:
    playerIndex = 1;
    break; // team2[1] - Jungle Vermelho
case 4:
    playerIndex = 2;
    break; // team1[2] - Mid Azul
case 5:
    playerIndex = 2;
    break; // team2[2] - Mid Vermelho
```

**Se N√ÉO estiver assim, corrija!**

---

### **PASSO 2: Adicionar logs para debug**

**No DraftController.java:**

```java
@PostMapping("/match/draft-action")
public ResponseEntity<?> processDraftAction(@RequestBody DraftActionRequest request) {
    log.info("üéØ [DraftController] Recebido draft-action: {}", request);
    
    boolean success = draftFlowService.processAction(
        request.matchId(),
        request.actionIndex(),
        request.championId(),
        request.playerId()
    );
    
    if (success) {
        log.info("‚úÖ [DraftController] A√ß√£o processada com sucesso");
        return ResponseEntity.ok(Map.of("success", true));
    } else {
        log.warn("‚ùå [DraftController] A√ß√£o rejeitada - valida√ß√£o falhou");
        return ResponseEntity.badRequest().body(Map.of(
            "success", false,
            "error", "A√ß√£o inv√°lida - verifique logs do backend"
        ));
    }
}
```

**No DraftFlowService.processAction():**

```java
@Transactional
public synchronized boolean processAction(long matchId, int actionIndex, String championId, String byPlayer) {
    log.info("üîµ [processAction] Iniciando: matchId={}, actionIndex={}, championId={}, byPlayer={}", 
        matchId, actionIndex, championId, byPlayer);
    
    DraftState st = states.get(matchId);
    if (st == null) {
        log.warn("‚ùå [processAction] DraftState n√£o encontrado para matchId={}", matchId);
        return false;
    }

    // ‚úÖ CORRE√á√ÉO #6: Normalizar championId antes de processar
    final String normalizedChampionId = normalizeChampionId(championId);
    if (normalizedChampionId == null) {
        log.warn("‚ùå [processAction] championId inv√°lido ap√≥s normaliza√ß√£o: {}", championId);
        return false;
    }
    log.info("‚úÖ [processAction] championId normalizado: {} -> {}", championId, normalizedChampionId);

    if (st.getCurrentIndex() >= st.getActions().size()) {
        log.warn("‚ùå [processAction] Draft j√° completo: currentIndex={}, totalActions={}", 
            st.getCurrentIndex(), st.getActions().size());
        return false;
    }
    
    if (actionIndex != st.currentIndex) {
        log.warn("‚ùå [processAction] actionIndex diferente: esperado={}, recebido={}", 
            st.currentIndex, actionIndex);
        return false;
    }
    
    DraftAction prev = st.actions.get(actionIndex);
    
    // valida se jogador pertence ao time da a√ß√£o
    if (!st.isPlayerInTeam(byPlayer, prev.team())) {
        log.warn("‚ùå [processAction] Jogador {} n√£o pertence ao team {} (a√ß√£o {})", 
            byPlayer, prev.team(), actionIndex);
        log.warn("    Team 1 players: {}", st.getTeam1Players());
        log.warn("    Team 2 players: {}", st.getTeam2Players());
        return false;
    }
    log.info("‚úÖ [processAction] Jogador {} validado para team {}", byPlayer, prev.team());
    
    boolean alreadyUsed = st.actions.stream()
            .filter(a -> a.championId() != null && !SKIPPED.equalsIgnoreCase(a.championId()))
            .anyMatch(a -> normalizedChampionId.equalsIgnoreCase(a.championId()));
    if (alreadyUsed) {
        log.warn("‚ùå [processAction] Campe√£o {} j√° foi usado", normalizedChampionId);
        return false;
    }
    log.info("‚úÖ [processAction] Campe√£o {} dispon√≠vel", normalizedChampionId);
    
    // ‚úÖ CORRE√á√ÉO: Buscar nome do campe√£o antes de criar DraftAction
    String championName = dataDragonService.getChampionName(normalizedChampionId);
    log.info("‚úÖ [processAction] Campe√£o name: {}", championName);
    
    DraftAction updated = new DraftAction(
        prev.index(), 
        prev.type(), 
        prev.team(), 
        normalizedChampionId,
        championName,
        byPlayer
    );
    st.getActions().set(actionIndex, updated);
    st.advance();
    st.markActionStart();
    
    log.info("‚úÖ [processAction] A√ß√£o salva: {} ({})", championName, normalizedChampionId);
    log.info("‚úÖ [processAction] Avan√ßando para pr√≥xima a√ß√£o: currentIndex={}", st.getCurrentIndex());
    
    persist(matchId, st);
    broadcastUpdate(st, false);
    
    if (st.getCurrentIndex() >= st.getActions().size()) {
        log.info("üéâ [processAction] Draft completado!");
        broadcastDraftCompleted(st);
    }
    
    return true;
}
```

---

### **PASSO 3: Verificar logs ap√≥s clicar**

Depois de adicionar os logs, quando voc√™ clicar no campe√£o:

**Verificar backend.log:**

```bash
tail -f backend.log | grep -E "DraftController|processAction"
```

**Esperar ver:**

```
üéØ [DraftController] Recebido draft-action: {matchId=..., championId=...}
üîµ [processAction] Iniciando: matchId=..., actionIndex=15, championId=...
‚úÖ [processAction] championId normalizado: Ahri -> 103
‚úÖ [processAction] Jogador validado para team 1
‚úÖ [processAction] Campe√£o dispon√≠vel
‚úÖ [processAction] A√ß√£o salva: Ahri (103)
‚úÖ [processAction] Avan√ßando para pr√≥xima a√ß√£o: currentIndex=16
‚úÖ [DraftController] A√ß√£o processada com sucesso
```

**Se ver erro:**

- ‚ùå "Jogador n√£o pertence ao team" ‚Üí Problema de valida√ß√£o de jogador
- ‚ùå "actionIndex diferente" ‚Üí Frontend enviando √≠ndice errado
- ‚ùå "Campe√£o j√° foi usado" ‚Üí Duplicata

---

## üìä **FORMATO DO JSON - AVALIA√á√ÉO**

### **JSON Atual:**

```json
{
  "actions": [...],
  "team1": [...],
  "team2": [...]
}
```

**Avalia√ß√£o:** ‚úÖ **EST√Å BOM!**

- ‚úÖ Todas as a√ß√µes est√£o mapeadas com index/type/team/championId/championName
- ‚úÖ Times t√™m todos os atributos (mmr, lane, summonerName)
- ‚úÖ F√°cil de iterar pelas a√ß√µes em ordem

**N√£o precisa mudar!** O formato est√° funcional.

---

## üéØ **RESUMO DAS A√á√ïES**

1. ‚úÖ **Verificar `getPlayerForTeamAndIndex()`** - Certifique-se que os √≠ndices est√£o corretos
2. ‚úÖ **Adicionar logs no DraftController e processAction()** - Para ver onde falha
3. ‚úÖ **Testar novamente** - Clicar no campe√£o e observar logs
4. ‚úÖ **Analisar erro espec√≠fico** - Corrigir baseado nos logs

---

**Data:** 2025-10-02  
**Status:** üî¥ Aguardando corre√ß√£o da ordem e debug de logs
